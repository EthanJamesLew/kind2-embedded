node a (x1: int; x2: int) returns (y1: int; y2: int);
var z:int;
var z2:int;
let
   z = x1;
   z2 = 3;
   y1 = z + x1 + z2;
   y2 = z2;
tel

node b(x1:int; x2:int) returns (y: int);
var z1:int;
var z2:int;
let
  (z1, z2) = a(y, x2); -- should fail
  -- y = z2; -- should not fail
  y = z1; -- should fail
tel

-- node c (x:int) returns (y: int);
-- var av:int;
-- var bv:int;
-- (*@contract
--    assume y = x;    -- case 1. not allowed as assumption should not depend on current value of y 
--    assume x = a(y + av); -- case 2a. not allowed if a uses current value of y
-- *)

-- tel
--    av = a(bv); -- case 2b. (av-> (a.y -> a.z, a.z -> bv)
--                             av -> {a.y, a.z, a.bv}, a.y -> a.z, a.z -> a.bv
--                            )
--    bv = b(av); -- case 2b.
--    x = pre("pre_y" + pre(a(y))); -- case 3. x' = (y + a(y)); normalizing (similar to SSA)  
-- let
